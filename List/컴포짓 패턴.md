# 의도

사용자로 하여금 개별 객체와 복합 객체를 모두 동일하게 다룰 수 있도록 하는 패턴

# 동기

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c4c3f91c-ed00-499a-b932-9844ee4edfa0/58f0c7f5-e4f8-4443-9b76-c8e7433b8da6/Untitled.png)

# 활용성

- 부분-전체의 객체 계통을 표현하고 싶을때
- 사용자가 객체의 합성으로 생긴 복합 객체와 개개의 객체 사이의 차이를 알지 않고도 자기 일을 할 수 있도록 만들고 싶을 때.
    - 사용자는 복합 구조의 모든 객체를 똑같이 취급하게 된다
        - 단일객체, 복합 객체를 동일하게 취급하게 된다.
            - ’복합객체: 폴더‘, ’단일객체: 파일‘로 대응시켜서 생각해보자.
            - 사용자는 폴더나 파일을 동일한 ‘컴포넌트’로 보고 동일한 ‘방식’으로 다룰 수 있다.
                - 즉 동일한 인터페이스로 다룰 수 있다는 것!
                - 예제: ‘크기를 계산한다’라는 동작
                    - 파일: 그 파일의 크기를 반환
                    - 폴더: 폴더안의 모든 파일과 서브폴더들의 크기를 합한 값을 반환
    - 자세히 보기
        - 간단한 예로 파일과 폴더 시스템을 생각해볼 수 있습니다. 파일 시스템에서 폴더는 여러 파일이나 다른 폴더를 포함할 수 있습니다. 여기서 개별 파일은 ‘단일 객체(Leaf)’, 폴더는 ’복합 객체(Composite)’입니다. 복합체 패턴을 사용하면, 사용자는 폴더나 파일을 동일한 ‘컴포넌트’로 보고 동일한 방식으로 다룰 수 있습니다. 예를 들어, ‘크기를 계산한다’라는 동작은 파일에 대해서는 그 파일의 크기를 반환하지만, 폴더에 대해서는 폴더 안의 모든 파일과 서브폴더들의 크기를 합한 값을 반환합니다. 이렇게 복합체 패턴을 사용하면, 클라이언트 코드는 내부 구조(단일 객체인지 복합 객체인지)에 신경 쓰지 않고, 모든 객체를 동일한 인터페이스로 다룰 수 있습니다. 이는 코드의 유연성을 높이고, 변경에 더 강한 설계를 가능하게 합니다.

# 구조

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c4c3f91c-ed00-499a-b932-9844ee4edfa0/bdeafe48-1f87-457e-8194-5e32de449bd0/Untitled.png)

# 참여자

- Component
    - 집합 관계에 정의될 모든 객체에 대한 인터페이스 정의
    - 
- Leaf
- Composite
- Client

# 결과

# 구현

# 예제 코드

# 관련 패턴