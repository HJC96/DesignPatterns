# 컴포짓 패턴

# 의도

- 사용자로 하여금 개별 객체와 복합 객체를 모두 동일하게 다룰 수 있도록 하는 패턴
- 트리 구조를 나타내기 좋다

# 동기

그래픽 편집기나 구조도 캡처 시스템 등에서 사용할 수 있다.

→ 사용자가 간단한 그림 구성요소들을 모아서 복잡한 다이어그램을 생성할 수 있게 하기 때문.

<img width="634" alt="image" src="https://github.com/HJC96/DesignPatterns/assets/87226129/1b558b3c-6cd7-4116-a1e1-40cce47379e7">


어떻게 구현하면 될까?

1. 하나의 추상화 클래스를 정의한다.
    1. 아래 예제에서는 Graphic
        1. Draw()
        2. Add()
        3. Remove()
        4. GetChild()
2. 그래픽의 서브클래스에서 연산을 구현한다.
    1. 이들 서브클래스는 구성 요소를 다루는데 필요한 연산은 구현 X
    2. Draw() 연산만 구현한다.
3. Graphic 객체와 집합 관계인 클래스를 만들어서 사용한다.
    1. 이때 Picture 클래스도 Draw() 연산을 구현한다.
    2. 이는 여러 그림 요소가 포함된 복합 그림도 실제로 그려지는 기본 행동을 제공하기 때문

<img width="556" alt="image" src="https://github.com/HJC96/DesignPatterns/assets/87226129/20ad8789-67b9-4d52-853d-b6c0077f1ee8">


MS 파워포인트 그룹 기능을 생각하면 쉽다.

# 활용성

- 부분-전체의 객체 계통을 표현하고 싶을때
- 사용자가 객체의 합성으로 생긴 복합 객체와 개개의 객체 사이의 차이를 알지 않고도 자기 일을 할 수 있도록 만들고 싶을 때.
    - 사용자는 복합 구조의 모든 객체를 똑같이 취급하게 된다
        - 단일객체, 복합 객체를 동일하게 취급하게 된다.
            - ’복합객체: 폴더‘, ’단일객체: 파일‘로 대응시켜서 생각해보자.
            - 사용자는 폴더나 파일을 동일한 ‘컴포넌트’로 보고 동일한 ‘방식’으로 다룰 수 있다.
                - 즉 동일한 인터페이스로 다룰 수 있다는 것!
                - 예제: ‘크기를 계산한다’라는 동작
                    - 파일: 그 파일의 크기를 반환
                    - 폴더: 폴더안의 모든 파일과 서브폴더들의 크기를 합한 값을 반환
    - 자세히 보기
        - 간단한 예로 파일과 폴더 시스템을 생각해볼 수 있습니다. 파일 시스템에서 폴더는 여러 파일이나 다른 폴더를 포함할 수 있습니다. 여기서 개별 파일은 ‘단일 객체(Leaf)’, 폴더는 ’복합 객체(Composite)’입니다. 복합체 패턴을 사용하면, 사용자는 폴더나 파일을 동일한 ‘컴포넌트’로 보고 동일한 방식으로 다룰 수 있습니다. 예를 들어, ‘크기를 계산한다’라는 동작은 파일에 대해서는 그 파일의 크기를 반환하지만, 폴더에 대해서는 폴더 안의 모든 파일과 서브폴더들의 크기를 합한 값을 반환합니다. 이렇게 복합체 패턴을 사용하면, 클라이언트 코드는 내부 구조(단일 객체인지 복합 객체인지)에 신경 쓰지 않고, 모든 객체를 동일한 인터페이스로 다룰 수 있습니다. 이는 코드의 유연성을 높이고, 변경에 더 강한 설계를 가능하게 합니다.

# 구조

<img width="605" alt="image" src="https://github.com/HJC96/DesignPatterns/assets/87226129/25c8fad3-a60b-4717-a9d6-9b7d6b478acf">

전형적인 Composite 객체 구조는 다음과 같다.

<img width="545" alt="image" src="https://github.com/HJC96/DesignPatterns/assets/87226129/34f1a1e2-ecff-4592-8785-57e73c69faaf">


# 참여자

- Component
    - 집합 관계에 정의될 모든 객체에 대한 인터페이스 정의
        - 모든 클래스에 해당하는 인터페이스에 대해서는 공통의 행동을 구현
    
    ```java
    interface Component {
        void operation();
        // 여기에 다른 공통 메서드들을 정의할 수 있습니다.
    		// 필요시 구현
    }
    ```
    
    - 전체 클래스에 속한 요소들을 관리하는 데 필요한 인터페이스를 정의
    
    ```java
    class Composite implements Component {
        // ... 이전 코드 ...
    
        public void add(Component component) {
            children.add(component);
        }
    
        public void remove(Component component) {
            children.remove(component);
        }
    
        public Component getChild(int index) {
            return children.get(index);
        }
    }
    ```
    
    - 순환 구조에서 요소들을 포함하는 전체 클래스로 접근 하는 데 필요한 인터페이스를 정의
        - 적절하다면 그 인터페이스를 구현
    
    ```java
    interface Component {
        void operation();
        Iterator<Component> createIterator();
    }
    ```
    
- Leaf
    - 가장 말단이 되는 객체
    - 가장 기본이 되는 객체의 행동만 정의
- Composite
    - 복합하는 요소들 저장
        - List<Childeren>
    - Component에 정의된 자식 관련 연산 구현
- Client
    - Component 인터페이스를 통해 복합 구조 내의 객체들을 조작

# 결과

- ‘기본 객체 ↔ 복합 객체’로 구성된 하나의 일관된 클래스 계통을 정의
    - 사용자 코드는 일반화된 상위 개념의 객체를 조작하는 방식으로 프로그래밍하면,
    - 런타임 기본 객체와 복합 객체를 구분하지 않고 일관되게 프로그래밍할 수 있다.
    - 공통된 메서드를 통해서 기본객체/복합객체 구분하지 않고 사용할 수 있다는 의미인듯.
- 코드가 단순해진다.
    - 위의 예제 처럼 공통된 메서드를 이용할때 파생되는 장점
- 새로운 종류의 구성요소를 쉽게 추가할 수 있다.
    - 새로운 요소가 추가되면 기존 구조들과 독립적으로 동작이 가능하다.
        - 예를 들어 새로운 객체를 추가하더라도, ’기존 기능 + a‘로 동작하지, ‘기존 기능’이 바뀌는건 아님
- 지나치게 범용성을 많이 가진다.
    - 가끔 복합체가 오직 한 개의 구성요소만 가졌으면 할 때가 있다. Composite 클래스만으로 타입 시스템을 통해 이런 제약을 가할 수 없다.
    
    ```java
    // Component 인터페이스
    interface Graphic {
        void draw();
    }
    
    // Leaf 클래스
    class Circle implements Graphic {
        public void draw() {
            System.out.println("Circle drawn.");
        }
    }
    
    // Composite 클래스
    class CompositeGraphic implements Graphic {
        private List<Graphic> children = new ArrayList<>();
    
        public void add(Graphic graphic) {
            children.add(graphic);
        }
    
        // 여기서 CompositeGraphic은 어떤 Graphic 타입도 받을 수 있음
        public void draw() {
            for (Graphic graphic : children) {
                graphic.draw();
            }
        }
    }
    ```
    
    예를들어 CompositeGraphic이 오직 Circle 객체만을 자식으로 가지길 원할 경우, 이를 강제하기 어렵다. add 메서드는 모든 Graphic 구현체를 받기 때문에, 컴파일 타임에 이를 제한할 방법이 없습니다.
    
    ```java
    public void add(Graphic graphic) {
        if (!(graphic instanceof Circle)) {
            throw new IllegalArgumentException("Only Circle instances are allowed");
        }
        children.add(graphic);
    }
    ```
    

# 구현

- 

# 예제 코드

```java

```

# 관련 패턴

- 장식자 패턴
- 플라이급 패턴
- 반복자 패턴
- 방문자 패턴
